# 设计模式学习笔记


- unit 0: UML基本介绍
- unit 1: 监听模式
- unit 2: 状态模式
- unit 3: 策略模式
- unit 4: 简单工厂模式与抽象工厂模式

## 开发心得

记得14年第一次找实习当时是做C++的MFC,这个框架很久远了,早已经忘记了这个怎么做了,但是唯一记得的就是当时的老大在我刚刚入职的时候不是需要我写功能,而是教我如何写代码和感受什么是面向对象,记得最早让我实现一个功能必须用到面向对象的思想,然后对这同样一个功能我写了很多个版本,每一个版本他都会给我指出很多问题,颇有一些苏格拉底教学风范,在每一次重构功能中,逐步明白什么是面向对象,但是当时并不知道有设计模式.

最早知道设计模式是在16年吧,当时看到有一本书貌似叫做《Java设计模式》,随意翻了翻收获就已经很多了,但是一直以来并没有系统的学习和使用.

22年的时候有一种学习模式让我受益匪浅,那就是"学以致用",改变量>>学习量,也就是如果一天看了5本书,但是没有一个学习收获,那么实质上也等于没有学习,对技术工具书学习更是如此!

那么对于一个如此重要的概念--设计模式,如果需要内化成自己的工具,必然也需要建立"学习"->"改变"的这样一条道路,加油~



# 1. 监听模式

## 1.1 笔记

监听模式要明确谁是被观察者,谁是观察者, 被观察者与观察者是n对1的关系.

监听模式又名观察者模式,发布/订阅模式,模型(model)/视图(view)模式,源/监听器模式,从属者模式,这些都是监听者模式.

> 核心思想: 观察者与被观察者之间需要建立一种自动触发的模式.

这里又让想到了之前的MVC(model, view, control), 这里的MV就是模型/视图模式,而本质上也是监听者模式,通过监听被观察者的操作来做出相应. 在web或者移动端开发过程中都存在着大量的监听.而往往在coding中该如何设计,架构该如何处理就需要好好了解一下这个监听者模式了!


监听模式的设计要领:

1. 谁是观察者,谁是被观察者
2. 被观察者至少需要三个方法: 添加监听者,删除监听者,通知观察者

监听模式的两种不同类型:
1. 推模型: 向全体app用户推送更新消息
2. 拉模型: 观察者主动拉模型

## 1.2 练习

1. 在互联网广泛普及和快速发展的时代，信息安全被越来越多的人重视，其中账户安全是信息安全最重要的一个部分。很多网站都会有一个账号异常登录检测和诊断机制。当账户异常登录时，会以短信或邮件的方式将登录信息（登录的时间、地区、IP地址等）发送给已经绑定的手机或邮箱。
登录异常其实就是登录状态的改变。服务器会记录你最近几次登录的时间、地区、IP地址，从而得知你常用的登录地区；如果哪次检测到你登录的地区与常用登录地区相差非常大（说明是登录地区的改变），则认为是一次异常登录。而短信和邮箱的发送机制我们可以认为是登录的监听者，只要登录异常一出现就自动发送信息。
2. 思考还有什么监听者模型
   
   前后端其实就是一个监听者模型,服务器监听客户端的请求; 原神中游戏打怪之后得到了经验,是否触发升级; 空调的自动调温系统,例如温度升高达到了用户设置的温度是否需要停止升温; 键盘敲击相应系统; I/O请求, 系统一直在监听; 


# 2. 状态模式

水的状态有三种: 液体, 固体, 气体

![](img/WeChatfd6d0d799d9e62200b6403034fc527e3.png)

当水处于的温度不一样的时候, 它的状态也会随之改变.

## 2.1 方法一

建立一个Water类和抽象类State,SolidState,LiquidState,GaseousState三个继承State类

然后由Water在`监听温度方法`中用if-else的方式去判断当前的状态.

这种方法就使得Water中`监听温度方法`无法保持程序设计中的`开放封闭原则`


## 2.2 方法二

![](img/WeChat39179257ef16b612efbea19ce6c56097.png)

将是否属于某一个状态的判断方法定为State中的isMatch方法,让状态自行判断是否满足条件.


## 2.3 总结

设计要领:

1. 需要实现状态模式的时候,状态会很复杂,使用isMatch方法可以传入更多的信息
2. 每一种状态应当为只有唯一实例

优点:

1. 封装了状态转换代码,对状态转换进行集中管理,而不是分散到一个个的业务逻辑中.
2. 将每个状态独立出来,开发人员只关注该状态下的逻辑开发.


应用场景:

1. 一个操作中含有庞大的多分支的条件语句,这些分支依赖于该对象的状态,且每一个分支的业务逻辑都十分的复杂,因此可以使用状态模式进行拆分成为不同的分支逻辑,提高代码的可读性和可维护性.


## 2.4 练习
1. 我们在阅读文章时,如果觉得文章写的很好,我们就会评论、收藏两连发。如果处于登录情况下,我们就可以直接做评论,收藏这些行为。否则,跳转到登录界面,登录后再继续执行先前的动作。这里涉及的状态有两种:登录与未登录,行为有两种:评论,收藏。
    
    uml图如下图,代码在hw2.py![](img/hw2-uml.drawio.png)

2. 有哪些情况可以用状态模式?
   
   手机温度状态,高温降频;用户大V状态,大V在直播平台出厂都是有一些标识

# 3. 策略模式

核心思想: 对算法,规则进行封装, 使得替换算法和新增算法更加灵活

例如在图像识别中有多个算法, 可以通过策略模式将这些算法封装成一个类, 并且可以通过不同的算法来调用

需要注意的点:

1. 相同的策略类中需要有一个相同的算法函数, 否则无法调用
2. 策略的具体实现,可以有多个不同的算法实现

优点:

1. 减少了if-else
2. 方便扩展

> 感觉这个就很有OOD的特性, 万事万物皆对象, 都封装成一个类的方式

## 3.1 练习

1. 人脸识别中有多个算法, 可以通过策略模式将这些算法封装成一个类, 并且可以通过不同的算法来调用

2. 有哪些场景中可以使用策略模式?
   
   人脸识别中不同算法的调用; 在问答中对不同文本匹配算法的调用做切换

# 4. 工厂模式

工厂模式: 用于创造对象的设计模式.

简单工厂模式: 使用string字符串去确定工厂加工出的类

抽象工厂模式: 简单工厂模式, 将所有的类分为了一个类别, 而抽象工厂模式将分为了多个类别的简单工厂模式, 再通过这些简单工厂模式来创建类.

> 注意: 工厂模式仅仅是用来创建对象的

## 4.1 练习

1. 工厂模式的应用场景?
   
   例如unit 3中的策略模式,可以和工厂模式一起使用

2. 将unit 3中的策略模式,用工厂模式进行实现

# 5. 组合模式


# 6. 构建模式

## 6.1 概念
又名 建造者模式或者生成器模式 ,核心思想:创建过程和产品本身分离开.

意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

何时使用：一些基本部件不会变，而其组合经常变化的时候。

如何解决：将变与不变分离开。

关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。

应用实例：
   1. 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。
   2. JAVA 中的 StringBuilder。

优点：
   1. 建造者独立，易扩展。
   2. 便于控制细节风险。

缺点：
   1. 产品必须有共同点，范围有限制。
   2. 如内部变化复杂，会有很多的建造类。

使用场景：
1. 需要生成的对象具有复杂的内部结构。
2. 需要生成的对象内部属性本身相互依赖。

注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。

## 6.2 个人感悟

构建模式主要是将复杂的构造将其表示分离,这里主要是利用了解构与组装的概念,将构造过程和产品本身分离开.

这里让我想到了面向对象,为什么会有继承,其实if-else也可以coding,但是为什么需要面向对象呢? 答案应该是if-else写10000行恐怕就只有开发者自己能够看懂了.

我想这里面有一个`零件`的概念,把复杂的东西一步一步的拆解,将其变成零件,哪个零件坏了修哪个,这样就可以控制复杂的东西的变化,而不需要管理复杂的东西的变化,模块化了之后才能做到复杂性可控制.

关键词: 解构

## 6.3 练习

1. 肯德基套餐的实现方案
类图:
![](./unit%205/img/class.drawio.png) 

## 参考资料
1. 《大话设计模式》
2. 《人人都懂设计模式》
3. [菜鸟设计模式](https://www.runoob.com/design-pattern/abstract-factory-pattern.html)